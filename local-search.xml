<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>TCP知识总结(二)——TCP连接建立与三次握手</title>
    <link href="/2022/03/31/TCP%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93-%E4%BA%8C-%E2%80%94%E2%80%94TCP%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E4%B8%8E%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/"/>
    <url>/2022/03/31/TCP%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93-%E4%BA%8C-%E2%80%94%E2%80%94TCP%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E4%B8%8E%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="一、三次握手"><a href="#一、三次握手" class="headerlink" title="一、三次握手"></a>一、三次握手</h2><p>TCP是面向连接的，因此在使用前，必须先建立TCP连接。而TCP连接是通过三次握手来进行的。</p><pre><code class="hljs"> &#123;% asset_img 1.png [图 1] %&#125;</code></pre><p>以上的三次交互，就是TCP的三次握手</p><h2 id="第一次握手"><a href="#第一次握手" class="headerlink" title="第一次握手"></a>第一次握手</h2><ol><li>客户端 和 服务端都处于 CLOSED 状态。</li><li>服务端 首先开启监听端口，监听是否有客户端的访问请求，因此服务端进入 LISTEN 状态。</li><li>客户端 随机初始化序号(client_isn)。 并将这个序号置于TCP头部的 <em>序号</em>字段中，同时将TCP头部字段中的SYN标志位置为1（表示此报文为SYN报文）</li><li>客户端发送第一个SYN报文，表示向服务端发起连接，该报文不包含应用层的数据。</li><li>客户端变为 SYN-SENT ， SYN已发送状态。 </li><li><img src="/2022/03/31/TCP%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93-%E4%BA%8C-%E2%80%94%E2%80%94TCP%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E4%B8%8E%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/2.png" class="" title="[图 1]"></li></ol><img src="/2022/03/31/TCP%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93-%E4%BA%8C-%E2%80%94%E2%80%94TCP%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E4%B8%8E%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/3.png" class="" title="[图 1]"><h2 id="第二次握手"><a href="#第二次握手" class="headerlink" title="第二次握手"></a>第二次握手</h2><ol><li>服务端接收到客户端发送的SYN报文</li><li>服务端随机初始化自己的序号(server_isn)，并将序号放入TCP头部字段的 <em>序号</em>字段</li><li>服务端将 client_isn+1 作为ACK(确认应答号)填入TCP头部</li><li>服务端 将 TCP头部中 SYN和ACK标志置为1.</li><li>发送该报文返回给客户端， 此报文不包含应用层数据。</li><li>服务器进入 SYN_RECV 状态</li><li><img src="/2022/03/31/TCP%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93-%E4%BA%8C-%E2%80%94%E2%80%94TCP%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E4%B8%8E%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/4.png" class="" title="[图 1]"></li></ol><h2 id="第三次握手"><a href="#第三次握手" class="headerlink" title="第三次握手"></a>第三次握手</h2><p> 客户端接收到服务端报文后，还需要向服务端返回一个应答报文。</p><ol><li>客户端 置TCP首部ACK标志位为1.</li><li>客户端 在TCP首部的确认应答号ACK处，填入 server_isn + 1 </li><li>如果有需要发送的数据，此时放入在TCP头部的数据部分。</li><li>客户端进入 <strong>ESTABLISHED</strong> 状态。</li><li>服务端接收到报文， 也进入<strong>ESTABLISHED</strong> 状态。</li><li><img src="/2022/03/31/TCP%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93-%E4%BA%8C-%E2%80%94%E2%80%94TCP%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E4%B8%8E%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/5.png" class="" title="[图 1]"></li></ol><h1 id="TCP连接为什么一定是三次握手？"><a href="#TCP连接为什么一定是三次握手？" class="headerlink" title="TCP连接为什么一定是三次握手？"></a>TCP连接为什么一定是三次握手？</h1><h2 id="一、-防止客户端连续发送的SYN造成混乱"><a href="#一、-防止客户端连续发送的SYN造成混乱" class="headerlink" title="一、 防止客户端连续发送的SYN造成混乱"></a>一、 防止客户端连续发送的SYN造成混乱</h2><p>当一个客户连续发送了多次SYN 建立连接报文。 由于网络堵塞等原因，会造成 <em>【旧的SYN】 比 【新的SYN】 先到达了服务端</em>。</p><ol><li>当服务端收到 【旧SYN】 ， 会根据【旧SYN】中携带的 client_isn 返回一个带有 client_isn + 1 的ACK</li><li>此时由于客户端已经发送了【新SYN】，所以当客户端收到了 对于 【旧SYN】的ACK时，客户端通过上下文会发现，这个ACK并不是我想要的，它是一个对历史连接的回应。</li><li>于是客户端会发送一个 RST 报文， 中断连接。</li><li><img src="/2022/03/31/TCP%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93-%E4%BA%8C-%E2%80%94%E2%80%94TCP%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E4%B8%8E%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/6.png" class="" title="[图 1]"></li></ol><h3 id="那为什么一定是三次？如果两次会有什么结果？"><a href="#那为什么一定是三次？如果两次会有什么结果？" class="headerlink" title="那为什么一定是三次？如果两次会有什么结果？"></a>那为什么一定是三次？如果两次会有什么结果？</h3><p>对当前这个问题而言，如果只有两次握手<strong>即客户端发送一次，服务端返回一次）</strong>。 如果不进行第三次握手（<strong>即客户端不判断从服务端返回的ACK是否对应了最新发送的连接请求</strong>）这就客户端无法判断是否当前的连接是一个历史连接。如果无脑用，则会导致传输数据错误。</p><h2 id="二、同步双方初始化序列号SYN"><a href="#二、同步双方初始化序列号SYN" class="headerlink" title="二、同步双方初始化序列号SYN"></a>二、同步双方初始化序列号SYN</h2><p>SYN作为可靠性传输的一个关键因素，起作用主要包括</p><ol><li>去重： 接收方去除重复数据</li><li>按序接收：接收方根据数据包的序列号按序接收</li><li>标识发送已确认的数据包： 确认哪些已经被对方成功接受</li></ol><p>意义： 因为客户端在第一握手的时候会发送一个带有 <em>初始序列号</em>的SYN，那么就需要服务端发送回一个SYN确认报文，同时也要发送一个对<em>初始序列号</em>的接受不了报文。<br>将这两个报文合并在一个TCP头部段的不同字段中，则将四次握手合并成三次握手。</p><img src="/2022/03/31/TCP%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93-%E4%BA%8C-%E2%80%94%E2%80%94TCP%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E4%B8%8E%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/7.png" class="" title="[图 1]"><p>两次握手的问题：只保证了发送方的初始序列号被成功接收，但是服务端无法确认是否发送方接收到了服务端的 <em>初始序列号</em></p><h2 id="三、避免资源浪费"><a href="#三、避免资源浪费" class="headerlink" title="三、避免资源浪费"></a>三、避免资源浪费</h2><p>如果客户端的SYN遭遇了网络阻塞，重复发送了多次的SYN， 那么服务器会建立多个无效的连接，造成资源浪费。</p><img src="/2022/03/31/TCP%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93-%E4%BA%8C-%E2%80%94%E2%80%94TCP%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E4%B8%8E%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/8.png" class="" title="[图 1]"><h2 id="三次握手的好处、-两次和四次的问题"><a href="#三次握手的好处、-两次和四次的问题" class="headerlink" title="三次握手的好处、 两次和四次的问题"></a><strong>三次握手的好处、 两次和四次的问题</strong></h2><ol><li>减少双方的资源浪费</li><li>同步双方初始化序列号，从而保证不重复，不丢弃，不乱序</li></ol><p>两次握手： 无法解决历史连接问题，造成资源浪费，也无法同步初始化序列号<br>四次握手： 三次握手已经足够可靠，四次握手增加了包丢失的几率，没有必要且浪费了资源。</p><h2 id="ISN-初始化"><a href="#ISN-初始化" class="headerlink" title="ISN 初始化"></a>ISN 初始化</h2><ol><li><p>ISN相同会导致的问题：<br>如果一个已经失效的连接被重新使用了，如果有历史报文残留在网络中。<br>那么如果 <em>旧报文的序列号 与 新报文的序列号相同</em> 那么无法分辨出接收到的序列号是否是历史序列号，如果历史报文被新的连接接受了，并且作为新报文使用，则会出现数据错乱的情况。</p></li><li><p>ISN非重初始化的目的:</p><ol><li>在每次建立连接之前重新初始化序列号，从而根据序列号将不属于本连接的报文段丢弃（旧报文段的序列号一定会违反当前序列号）</li><li>保证安全性，防止通过伪造相同序列号的TCP报文，来让接收方接收到一些非法数据。（SYN攻击）</li></ol></li></ol><h2 id="MSS作用"><a href="#MSS作用" class="headerlink" title="MSS作用"></a>MSS作用</h2><p>MSS（ Maximum Segment Size ）: 除去IP和TCP头部之后， 一个网络包所能容纳的TCP <strong>数据</strong> 的最大长度。<br>MTU（Maximum Transmission Unit）: 一个网络包的最大长度（TCP头部+TCP数据），一般为1500字节</p><p>如果由IP层进行分片：</p><p>当IP曾有一个超过MTU大小的数据，那么IP层要对其进行分片，即把数据分成若干片，每一片都小于MTU。然后发送给目标主机，由目标主机的IP层对这些分片的数据进行重组，再交给上一层TCP传输层。</p><p>如果由TCP层进行分片：</p><p>当接收方发现TCP报文（头部+数据）的某一片丢失了，则不会发送ACK，那么接收方会重传<strong>整个TCP报文</strong></p><p>这两种功能方法的效率都很低，他们都会重传整个报文。</p><h3 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h3><p>TCP协议在建立连接的时候，会协商双方的MSS，当TCP发现数据超过MSS的时候，会执行分片。分片后的数据作为单独的数据进行传输，从而如果传输过程中丢失，则只会传输丢失的包。</p><p>从而形成的IP包不会大于MTU，因此不用进行IP分片； 如果TCP分片丢失，重发也是以MSS为单位的，而不会重传所有分组。</p><h2 id="SYN-Flood攻击"><a href="#SYN-Flood攻击" class="headerlink" title="SYN Flood攻击"></a>SYN Flood攻击</h2><p>攻击者短时间内伪造不同IP地址的SYN报文， 服务端每收到一个SYN报文，就进入SYN_RCVD 状态，但是攻击者不会回应服务端发送的ACK+SYN 报文（第二次握手），从而无法得到未知IP主机的ACK应答，但是SYN接收队列是有上限的。<br>因此会逐渐占满SYN队列，导致服务器无法接受正常用户的SYN报文请求，从而不能为正常用户服务。</p><img src="/2022/03/31/TCP%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93-%E4%BA%8C-%E2%80%94%E2%80%94TCP%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E4%B8%8E%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/9.png" class="" title="[图 1]"><img src="/2022/03/31/TCP%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93-%E4%BA%8C-%E2%80%94%E2%80%94TCP%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E4%B8%8E%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/10.png" class="" title="[图 1]"><p>解决方法：</p><ol><li>修改Linux 内核参数，当SYN队列满后如何处理（对新的SYN恢复RST丢弃连接）</li><li>使用 tcp_syncookies 的方式对应攻击： net.ipv4.tcp_syncookies &#x3D; 1 . 当SYN队列满后，后续的SYN包不进入SYN队列。<ol><li>服务器计算出一个cookie值， 以 SYN+ACK 的 序列号返回客户端</li><li>服务器从积压的SYN队列中删除SYN请求，让端口打开，准备建立新的连接。</li><li>服务端接受客户端应答报文ACK时，会检查ACK合法性。 因为cookie的性质，如果收到多次带有相同cookie的请求，则视为非法，记录地址信息，并丢弃从这个IP来的请求。</li><li>如果合法则进入Accept队列。（保证只有当客户端正确应答ACK时才进入Accept队列）。</li><li>最后使用 accep() 的socket接口从 Accpet队列中取出连接。</li></ol></li></ol><img src="/2022/03/31/TCP%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93-%E4%BA%8C-%E2%80%94%E2%80%94TCP%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E4%B8%8E%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/11.png" class="" title="[图 1]"><img src="/2022/03/31/TCP%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93-%E4%BA%8C-%E2%80%94%E2%80%94TCP%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E4%B8%8E%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/12.png" class="" title="[图 1]">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>TCP知识总结(一)——TCP基础</title>
    <link href="/2022/03/31/TCP%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93-%E4%B8%80-%E2%80%9C/"/>
    <url>/2022/03/31/TCP%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93-%E4%B8%80-%E2%80%9C/</url>
    
    <content type="html"><![CDATA[<h2 id="一、-TCP概述"><a href="#一、-TCP概述" class="headerlink" title="一、 TCP概述"></a>一、 TCP概述</h2><p>IP协议是网络层的一个协议，但是IP协议是不可靠的，不能保证数据的完整性，有序性，可靠性。因此需要在传输层中是用TCP来保证数据的可靠性。</p><p>TCP 是一个 <strong>传输层</strong>的可靠数据传输服务，保证数据包的不坏、不乱、不丢。</p><img src="/2022/03/31/TCP%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93-%E4%B8%80-%E2%80%9C/5.png" class="" title="[图 1]"><p>TCP的特点是：</p><ol><li>面向连接： TCP的链接是一对一的，端对端的； 与UDP不同，UDP可以通过一个主机的一个进程向多个主机发送消息（无连接分用）。但是TCP必须通过多线程&#x2F;进程 对多个主机进行连接以后才能 ‘一对一’地发起通信</li><li>可靠的：无论网络中出现了怎样的链路变化，TCP可以保证一个报文一定能到达接收端。（重传机制保证其可靠性）</li><li>字节流：对重复的数据报文会自动丢弃，并且保证了数据分组的有序性。</li></ol><p>因此我们说，TCP是一个面向连接的，可靠的，基于字节流的传输层通信协议。</p><h2 id="二、-TCP头部字段的结构"><a href="#二、-TCP头部字段的结构" class="headerlink" title="二、 TCP头部字段的结构"></a>二、 TCP头部字段的结构</h2><p>TCP字段分为两个部分 ： 头部字段以及数据字段。</p><img src="/2022/03/31/TCP%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93-%E4%B8%80-%E2%80%9C/1.png" class="" title="[图 1]"><ol><li>序列号（SYN sychronize Sequence Numbers）：在 <strong>建立连接</strong>时由接收和发送双方随即选择的序列号。 序列号是数据段segment中的<em>第一个字节的编号</em>，如果将一个segment拆成两个，那么序列号也会跟着变化。 </li><li>确认应答号（ACK: Acknowledge character）: ACK 用于解决丢包的问题，ACK中返回的是 <em>希望下一次接收到的数据段的序列号</em>，发送端根据ACK的回复，来确认，在ACK序列号之前的所有数据段都被成功接收了（累计确认原则）。</li><li>控制位：<img src="/2022/03/31/TCP%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93-%E4%B8%80-%E2%80%9C/2.png" class="" title="[图 1]"></li></ol><h2 id="三、-TCP连接的基础"><a href="#三、-TCP连接的基础" class="headerlink" title="三、 TCP连接的基础"></a>三、 TCP连接的基础</h2><p>TCP 连接的主要作用是维护一些与 <strong>可靠性、流量控制相关的变量</strong>， 比如 Socket， 序列号，窗口大小。</p><ol><li><p>确定连接</p><p> TCP通过是通过一个 <strong>四元组</strong>来确定一个唯一链接</p> <img src="/2022/03/31/TCP%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93-%E4%B8%80-%E2%80%9C/3.png" class="" title="[图 1]"><p> 其中 ：<br> 源地址与目的地址为 <em>32位</em>， 保存在<strong>IP数据报头部</strong>， 是协助 网络层的IP协议发送报文给对方主机，在路由中进行转发的时候使用的。</p><p> 源端口号与源地址为 <em>16位</em>, 保存在 <strong>TCP头部中</strong> ， 作用是让主机知道应该把这个数据报文发给哪个端口(进程).</p></li><li><p>最大连接数</p><p>TCP连接中，服务器会在某个端口上进行监听，如果收到来自其他主机的TCP链接请求，服务器会创建一个新的Socket来处理请求，并同时保留原本的监听Socket用以接收后序的来自其他主机的TCP访问请求(Socket中的accpet)。<br>这样的优点是：使服务器端的 <strong>目标端口和目标地址固定</strong>。</p><p>理论最大： 不进行限制，客户端能发多少连接，全都发送<br> $$<br> 最大TCP连接数 &#x3D; 客户端的IP数 * 客户端的端口数<br> $$</p><p>但是一个服务器不可能同时处理无穷个TCP连接，有一些实际约束来限制TCP连接的数量</p></li><li><p>对连接数量的实际约束<br> 从TCP四元组入手进行限制</p><ol><li>限制源端口号的资源：通过ip_local_port_range 修改端口范围 （发送方限制）</li><li>限制目标端口的资源和目标IP地址</li></ol><p> 从其他方面限制：<br>3. 限制文件描述符资源： 因为每个进程可以打开的文件描述符有限，可通过修改单个进程可打开的文件描述符数量做出修改。<br>4. 线程资源： 因为每建立一个TCP就会创建一个新的线程，如果线程数不断增大，就会引发C10K问题，导致建立连接的时间花费越来越大。但是这个问题可以通过IO多路复用解决： 即一个线程处理管理多个TC连接资源，减少总线程数量<br>5. 内存限制： 对每个TCP连接而言，主机都需要分配给他们一定的内存空间，作为缓冲区。 解决方法： 杀死某些特别占内存的进程<br>6. CPU资源： 一旦CPU占用率长时间为100%，则无法执行其他指令，此时尝试重启。</p> <img src="/2022/03/31/TCP%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93-%E4%B8%80-%E2%80%9C/4.png" class="" title="[图 1]"></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>TCP可靠性知识总结（二）——流量控制与拥塞控制</title>
    <link href="/2022/03/27/TCP%E5%8F%AF%E9%9D%A0%E6%80%A7%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E4%B8%8E%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/"/>
    <url>/2022/03/27/TCP%E5%8F%AF%E9%9D%A0%E6%80%A7%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E4%B8%8E%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="一、流量控制与拥塞控制的区别"><a href="#一、流量控制与拥塞控制的区别" class="headerlink" title="一、流量控制与拥塞控制的区别"></a>一、流量控制与拥塞控制的区别</h2><p>首先要注意，流量控制与拥塞控制的本质区别在于：</p><p>流量控制针对的是<strong>端对端传输</strong>，是发送方根据接收方的实际接收能力，调整发送的数据量。避免了发送方浪费资源和性能。</p><p>拥塞控制是对于<strong>整个网络来说的</strong>，其目的是为了防止 <strong>发送方</strong> 无休止的发送数据包，从而整个网络都被发送方数据所占据，导致整体的网络通道拥挤。</p><h2 id="二、操作系统缓冲区与滑动窗口的关系"><a href="#二、操作系统缓冲区与滑动窗口的关系" class="headerlink" title="二、操作系统缓冲区与滑动窗口的关系"></a>二、操作系统缓冲区与滑动窗口的关系</h2><p>发送窗口和接收窗口的数据都存放在终端的操作系统 <strong>内存缓冲区</strong> 中，而缓冲区是会被操作系统调整的(剩余缓存的大小反映了处理能与的强弱)</p><p>一般会有以下两种情形造成缓存区变得很小，或没有缓存区而导致<strong>窗口关闭</strong></p><ol><li><p>应用程序没有及时读取缓存：</p><p> 接收方在成功接收了数据之后，接收方的应用没有及时从缓冲区中获取数据，那么发送过来的数据就会存储在缓存区中。这会导致接收方的窗口不断变小，直到缓存区完全被数据填满以后，窗口关闭。<br> 即，当<br> $$ 接收方应用获取数据的速度 &lt; 发送方传输数据的速度 $$</p> <img src="/2022/03/27/TCP%E5%8F%AF%E9%9D%A0%E6%80%A7%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E4%B8%8E%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/1.png" class="" title="[图 1]"></li><li><p>接收方系统资源非常紧张</p><p> 这会导致接收方在接受到数据的时候无法立刻返回 <strong>携带接收方窗口大小的ACK</strong> 给发送方。<br> 这就导致发送方在没有收到新的窗口大小的情况下发送数据，此时发送的数据大小很可能已经大于了接收方的窗口大小。<br> 导致接收方无法处理数据包，从而丢弃数据包。</p><p> 更重要的是，在发送方发送了数据包以后收到了 <strong>延迟到达的ACK</strong> ， 此时发送方如果想调整窗口大小，会导致窗口大小变成负值。<br> <img src="/2022/03/27/TCP%E5%8F%AF%E9%9D%A0%E6%80%A7%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E4%B8%8E%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/2.png" class="" title="[图 2]"><br> 为了防止这种情况，TCP规定</p><p> <strong>不允许同时减少缓存且收缩窗口，只能先收缩窗口，过段时间再减少缓存</strong></p></li></ol><h2 id="三、窗口关闭的死锁"><a href="#三、窗口关闭的死锁" class="headerlink" title="三、窗口关闭的死锁"></a>三、窗口关闭的死锁</h2><p>当缓冲区的窗口大小为0时，发送方会停止传输数据，直到接收方返回一个ACK来通告空闲窗口大小。</p><p>但是，当接收方窗口大小为0，并且向发送方发送了<strong>关闭窗口</strong>的通告以后，如果没有给发送方发送空闲窗口大小，<br>或者空闲窗口的ACK在传输过程中丢失了，那么</p><p><strong>接收方一直等待发送方的空闲窗口ACK， 而发送方一直等待接收方的传输数据</strong></p><p>这种情况就叫做窗口关闭的死锁<br>    <img src="/2022/03/27/TCP%E5%8F%AF%E9%9D%A0%E6%80%A7%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E4%B8%8E%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/3.png" class="" title="[图 1]"></p><ol><li><p>解决方法(窗口探测报文 Window probe)<br> 窗口探测实际上就是使用了定时器的思想。 TCP为每个连接设置一个持续的定时器，如果TCP连接中有一方收到了0窗口通告，计时器就会启动。</p><p> 如果计时器超时，则会发送探测报文，询问接收方是否有空闲的窗口大小用来接收发送方的数据。<br> 接收方在返回的时候就会返回当前接收窗口的大小。</p><p> 窗口探测一般会探测3次，如果三次之后发现接收方依然是0窗口状态，则会中断TCP链接</p></li></ol><h2 id="四、糊涂窗口综合症"><a href="#四、糊涂窗口综合症" class="headerlink" title="四、糊涂窗口综合症"></a>四、糊涂窗口综合症</h2><p>虽然通过窗口探测报文解决了窗口关闭死锁问题，但是又出现了一个新问题。</p><p>如果接收方一旦有一点点缓存空间就发送ACK报文告诉发送方，那么通知的窗口会非常小（这里的非常小指的是窗口大小 &lt; MSS 大小，MSS默认为536字节），<br>此时就算只有几个字节，发送方也会告诉接收方 “可以发送了”。</p><p>MSS的定义: 最大分段数据长度，是TCP报文段中数据段的长度，并不包含TCP的首部字段。 MSS在TCP连接建立的时候定义，用于确定双方能收发的最大报文段长度。一般会以接收方 &#x2F; 发送方 提供的MSS的最小值确定这个值。<br>$$MSS &#x3D; TCP报文段长度 - TCP首部长度$$</p><p>此时就会产生SWS（发送方传输很慢，或接收方处理缓冲区速度很慢，或者两者都有）。<br>因为此时应用进程之间传输的报文数据量很小，甚至小于传输开销（TCP头部字段有40字节，有效载荷可能小于头部字段大小）<br>            <img src="/2022/03/27/TCP%E5%8F%AF%E9%9D%A0%E6%80%A7%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E4%B8%8E%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/4.png" class="" title="[图 2]"></p><ol><li><p>让接收方不通告小窗口给发送方，当接收方的缓存区窗口小于某个阈值 (即MSS与 1&#x2F;2缓存空间 中的较小值)，就会发送0窗口通告，阻止发送方发送数据。当缓存区中的窗口大小经过处理以后大于了MSS，则打开窗口。</p></li><li><p>让发送方避免发送小数据，使用Nagle算法尽量发送大块数据，避免网络中存在着许多小数据块。</p><ol><li>Nagle算法： 在任意时刻，最多只能由一个 <strong>未被确认(发送了但没有收到ACK)</strong> 的 **小段(小于MSS尺寸的数据块)**。</li></ol><p> 在发送数据的时候先把数据存入缓存，直到累计到了一定数量的数据才发送。</p><p> 或者当发送端明确收到了未确认数据的ACK，才发送当前数据（因为已经发送的数据大小也满足了最小值，所以当已经发送的数据被确认，那么根据确认信息也就可以知道对方窗口大小了）</p></li></ol><h2 id="五、拥塞控制"><a href="#五、拥塞控制" class="headerlink" title="五、拥塞控制"></a>五、拥塞控制</h2><p>当网络出现拥塞时依然发送大量数据包，则会导致数据丢失，延迟。此时TCP会重传数据，从而导致恶循环，加重网络拥塞。</p><p>TCP协议是一个无私的协议，当他检测到网络发生拥塞时，会自我牺牲，减少发送的数据量。</p><ol><li><p>拥塞窗口 cwnd&#x2F; CongWin</p><p> cwnd 是由<strong>发送方</strong>维护的变量，会根据网络的拥塞程度动态变化。<br> 当网络中没有拥塞，cwnd会增大 ； 当网络中出现拥塞 cwnd就减少</p></li><li><p>拥塞检测</p><p> 表现为分组丢失或分组延迟过大。当发送方没有在规定时间内接收到ACK报文，即发生超时重传时，则认为网络出现了拥塞。</p><p> 或者当接收方连续收到 <em>三个相同的ACK</em> 即发生拥塞</p></li><li><p>拥塞控制算法</p><p> TCP拥塞控制的原理就是动态的调整发送速率，有两种方法来调整cnwd</p><ol><li>加性增——乘性减： AIMD （也叫拥塞避免算法）</li></ol><p>增加发送速率的时候要稳健，一点点增加，谨慎地探测带宽。</p><p>Additive Increase:： 每个RTT将cwnd 增大<em>一个MSS</em><br>Multiplicative Decrease: 当发生拥塞后，cwnd直接减半 或 减少到1 ，以此减少发送速率。</p><ol><li>慢启动 Slow Start</li></ol><p> 当TCP初始化链接的时候， cnwd会被初始化为1， 但此时可用的带宽可能会远远大于cnwd的大小，如果此时依然使用AIMD， 那么cnwd增加的速度就太慢了。<br> 因此我们希望cnwd在刚开始的时候能够快速增加，直到<strong>某个阈值后再实施AIMD</strong>。<br>             <img src="/2022/03/27/TCP%E5%8F%AF%E9%9D%A0%E6%80%A7%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E4%B8%8E%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/5.png" class="" title="[图 2]"><br> 慢启动门限 ssthresh ：限制慢启动的一个状态变量，当$cnwd &lt; ssthresh$ 启用SS。 当$cnwd &gt; ssthresh$ 则使用AIMD算法。</p></li><li><p>拥塞发生后的处理方式</p></li></ol><p>给予AIMD，拥塞发生后由于要快速减少cwnd，但是在MD的过程中会产生两种情况</p><p>1）当发生了 <strong>超时重传</strong> 则会使用<strong>拥塞发生算法</strong></p><p>如果发生超时重传，说明此时网络中拥塞已经非常严重了，所以必须迅速降低cwnd<br>$$慢启动门限 ssthresh 设为 cwnd&#x2F;2$$<br>$$cwnd重置为1$$<br>然后开始执行 <strong>慢启动SS</strong>，但是慢启动的反应太过激烈，会造成网络卡顿<br>2） 快速恢复 Fast Recovery</p><p>如果发生了快速重传（收到了三个重复的ACK） ， 此时说明网络的拥塞还不是那么严重，至少还能收到ACK。<br>那么</p><p>$$慢启动门限 ssthresh 设为 cwnd&#x2F;2$$<br>$$cwnd 也设为 自身的一半 cwnd&#x2F;2$$<br>然后开始执行拥塞避免算法AIDM，后续cnwd会线性增长。</p><img src="/2022/03/27/TCP%E5%8F%AF%E9%9D%A0%E6%80%A7%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E4%B8%8E%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/5.png" class="" title="[图 2]">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>TCP可靠性知识点归纳(一)-重传机制与滑动窗口</title>
    <link href="/2022/03/25/TCP%E5%8F%AF%E9%9D%A0%E6%80%A7%E7%9F%A5%E8%AF%86%E7%82%B9%E5%BD%92%E7%BA%B3(%E4%B8%80)_%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6%E4%B8%8E%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    <url>/2022/03/25/TCP%E5%8F%AF%E9%9D%A0%E6%80%A7%E7%9F%A5%E8%AF%86%E7%82%B9%E5%BD%92%E7%BA%B3(%E4%B8%80)_%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6%E4%B8%8E%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<p>由于TCP是一种可靠的传输协议(不错，不乱，不丢)，因此一些思想是建立在rdt以及所衍生出的滑动窗口等内容的基础上</p><h2 id="一、重传机制"><a href="#一、重传机制" class="headerlink" title="一、重传机制"></a>一、重传机制</h2><p>由rdt2.0提出，当发送端的数据到达接收端时，接收端要发送一个ACK返回给发送方。当发送方发现数据包丢失的情况时候(收到重复ack或没有收到ack)，会启用重传机制。</p><p>ACK 中会包含期望得到的数据的序列号，与确认应答信息。</p><h3 id="1-1-超时重传-rdt3-0"><a href="#1-1-超时重传-rdt3-0" class="headerlink" title="1.1 超时重传( rdt3.0 )"></a>1.1 超时重传( rdt3.0 )</h3><p>当发送方发送一个数据后，会启动一个定时器，当超过指定时间没有收到对应ACK时，会重发该数据。</p><img src="/2022/03/25/TCP%E5%8F%AF%E9%9D%A0%E6%80%A7%E7%9F%A5%E8%AF%86%E7%82%B9%E5%BD%92%E7%BA%B3(%E4%B8%80)_%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6%E4%B8%8E%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/1.png" class="" title="[图 1]"><p>在设置<em>RTO(超时重传时间)</em> 时候，要特别注意对RTO的选择，其值应该略大于 *RTT(往返时延)*。在实际情况中，RTT是一个动态值，因此RTO也应该是一个动态值</p><p>缺点： 如果重新发送的数据再次超时，则TCP会采用 <em>超时间隔加倍</em> 策略。如果两次都超时，说明此时网络可能已经拥塞，不宜反复发送。</p><h3 id="1-2-快速重传-Fast-Re-transmit"><a href="#1-2-快速重传-Fast-Re-transmit" class="headerlink" title="1.2 快速重传(Fast Re-transmit)"></a>1.2 快速重传(Fast Re-transmit)</h3><p>和超时重传不同，快速重传不以计时器作为重传的触发， 而采用数据驱动重传</p><p>重传触发：<em>当收到3个重复的ACK时，则判定重复ACK中所期望的数据已经丢失</em>。</p><p>缺点： 发送端不知道是否只丢失了ACK所期望的包，还是ACK之后的包全都丢失了。</p><img src="/2022/03/25/TCP%E5%8F%AF%E9%9D%A0%E6%80%A7%E7%9F%A5%E8%AF%86%E7%82%B9%E5%BD%92%E7%BA%B3(%E4%B8%80)_%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6%E4%B8%8E%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/2.png" class="" title="[图 2]"><img src="/2022/03/25/TCP%E5%8F%AF%E9%9D%A0%E6%80%A7%E7%9F%A5%E8%AF%86%E7%82%B9%E5%BD%92%E7%BA%B3(%E4%B8%80)_%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6%E4%B8%8E%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/3.png" class="" title="[图 2]"><p>从图中可以看到，此时接收方没有收到Seq2所对应的数据，因此接收方会返回多个ACK2 来要求重发。<br>此时 <em>Seq3,Seq4,Seq5</em> 的数据包都已经成功到达。根据累计确认的原则，接收方在收到重发的<em>Seq2</em> 后，会返回最后一个成功收到的包 <em>ACK6</em>。</p><p>但是在重传的时候，根据TCP的不同实现（双方端口是否有缓存），可能会只重传<em>Seq2</em> (SR滑动窗口协议), 也可能会重传<em>从Seq2往后的所有数据包</em>(GBN滑动窗口协议)</p><h3 id="1-3-滑动窗口"><a href="#1-3-滑动窗口" class="headerlink" title="1.3 滑动窗口"></a>1.3 滑动窗口</h3><p>在rdt3.0 所提出的 “停等”机制，在RTT较长时会导致数据的传输效率变低，吞吐量变小。<br>因此提出了<em>流水线机制</em> ，发送方会一次行发送多个数据给接收方， 接收方会返回 $最后一个成功接收的数据的ACK$。 而滑动窗口协议就是对流水线机制的一个实现</p><h3 id="1-4-滑动窗口的分类"><a href="#1-4-滑动窗口的分类" class="headerlink" title="1.4 滑动窗口的分类"></a>1.4 滑动窗口的分类</h3><p>滑动窗口可以分为 GBN(Go-Back-N)  与 SR(Selective Repeat) 两种。</p><ol><li>GBN协议的特点：<ol><li>累计确认： 返回最后一个成功到达的数据的ACK</li><li>乱序丢弃： GBN的接收方是没有缓存的，因此如果收到的数据不是上一个ACK期望的数据，接收方会直接丢弃这个数据，并重新确认按序到达的序列最大的数据，将其ACK返回。<br>GBN乱序丢弃的特点，导致了可能会造成大量的重发分组，从而增加网络压力</li></ol></li><li>SR协议：<ol><li>在GBN的基础上增加了缓存机制，从而缓存乱序到达的分组</li><li>发送方为每个分组设置定时器，且只需要重传没有收到ACK的分组即可，避免了大量重传的问题。这是通过对收到的分组序列号排序所实现的。</li><li>发送方的窗口由N个连续的序列号组成，并且限制已发送且未确认的分组数量</li><li>当SR协议接收到乱序的分组时，接收方的滑动窗口不会向后移动，直到所有缺失的分组都收到以后，才会整体向右滑动  <img src="/2022/03/25/TCP%E5%8F%AF%E9%9D%A0%E6%80%A7%E7%9F%A5%E8%AF%86%E7%82%B9%E5%BD%92%E7%BA%B3(%E4%B8%80)_%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6%E4%B8%8E%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/8.png" class="" title="[图 5]"></li></ol></li><li>SR协议的困境问题</li></ol><p>当缓存区能用的序列号小于滑动窗口的窗口大小时，会产生困境问题。当接收方的ACK在传输过程中丢失，并且此时序列号在同一窗口内被复用，这会导致接收方无法区分不同的分组。</p><img src="/2022/03/25/TCP%E5%8F%AF%E9%9D%A0%E6%80%A7%E7%9F%A5%E8%AF%86%E7%82%B9%E5%BD%92%E7%BA%B3(%E4%B8%80)_%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6%E4%B8%8E%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/9.png" class="" title="[图 2]"><p>因此序列号空间大小与窗口尺寸应该满足：<br>$$发送方窗口尺寸+接收方窗口尺寸 &lt;&#x3D; 总序列号可用范围$$<br>$$即 N_S+N_R &lt;&#x3D; 2^k$$</p><h3 id="1-5-滑动窗口的结构"><a href="#1-5-滑动窗口的结构" class="headerlink" title="1.5 滑动窗口的结构"></a>1.5 滑动窗口的结构</h3><ol><li><p>窗口实现： 操作系统上开辟的一个缓存空间，发送方主机在收到接收方的应答之前，必须将发送未确认的数据保留在缓存区中。 如果在指定时间内收到了确认应答ACK，则可以将数据从缓存区中清除。</p></li><li><p>累计确认： 在滑动窗口中，发送方和接收方采用累计确认的原则。</p><img src="/2022/03/25/TCP%E5%8F%AF%E9%9D%A0%E6%80%A7%E7%9F%A5%E8%AF%86%E7%82%B9%E5%BD%92%E7%BA%B3(%E4%B8%80)_%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6%E4%B8%8E%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/4.png" class="" title="[图 2]"></li><li><p>窗口大小： 该信息被放在TCP的头部字段中，叫做window。 该信息是由接收端返回给发送端的ACK中，告知发送端目前接收端的缓存区域大小，从而让发送方控制每次发送数据的大小。</p></li><li><p>发送方每次发送的数据不能超过接收方窗口大小，否则接收方无法正常接收数据，造成丢包。</p></li><li><p>如果发送方确认到接收方的窗口大小为0，在接收到新的ACK通知接收方窗口有余量之前，发送方停止向接收方发送数据。</p></li><li><p>发送窗口结构<br>发送并确认、发送未确认、未发送但在对方处理范围内、未发送且超过接收方处理能力</p> <img src="/2022/03/25/TCP%E5%8F%AF%E9%9D%A0%E6%80%A7%E7%9F%A5%E8%AF%86%E7%82%B9%E5%BD%92%E7%BA%B3(%E4%B8%80)_%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6%E4%B8%8E%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/5.png" class="" title="[图 5]"><p> 当发送方确认到接收方的ACK后，会将窗口往右滑动，释放缓存资源</p></li><li><p>接收窗口结构<br>已成功接收并确认、未收到但可以收到的数据(窗口大小) 、未收到且超出处理能力的数据</p> <img src="/2022/03/25/TCP%E5%8F%AF%E9%9D%A0%E6%80%A7%E7%9F%A5%E8%AF%86%E7%82%B9%E5%BD%92%E7%BA%B3(%E4%B8%80)_%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6%E4%B8%8E%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/7.png" class="" title="[图 5]"></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>TCP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Thymleaf模版技术</title>
    <link href="/2022/02/24/Thymleaf%E6%A8%A1%E7%89%88%E6%8A%80%E6%9C%AF/"/>
    <url>/2022/02/24/Thymleaf%E6%A8%A1%E7%89%88%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="Thymleaf模版技术–基础使用"><a href="#Thymleaf模版技术–基础使用" class="headerlink" title="Thymleaf模版技术–基础使用"></a>Thymleaf模版技术–基础使用</h1><p>模版技术 ：<br>jsp是最早的模版， 其数据来自于服务器端，性能较差<br>模版就是一些框架，来做视图层处理，实际上就是用于显示数据的。</p><p>Thymeleaf 可以在web或者非web项目中使用，其基于HTML语言 ， 在此基础上加上了模版引擎语法。在Springboot中集成了模版技术。</p><h2 id="一、，模版配置："><a href="#一、，模版配置：" class="headerlink" title="一、，模版配置："></a>一、，模版配置：</h2><ol><li><p>需要在建立模块的时候选择相应的<strong>模版引擎</strong></p></li><li><p>将要使用的视图模版文件的时候放在resources的templates文件夹下。在controller中以视图的方式访问模版。</p><p> 可以在application.properties 中对模版引擎进行设置，相关依赖：</p><pre><code class="hljs"> &lt;dependency&gt;     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;     &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt;</code></pre></li><li><p>在application.properties中设置 </p><pre><code class="hljs"> spring.thymeleaf.cache=true  </code></pre><p>使用缓存，当用户访问以后，再次访问这个页面的时候，就是从内存中访问。上线之后设为true。但是开发阶段因为要修改模版，所以开发的时候一般设为false</p></li><li><p>设置模版的默认字符集和文件格式：</p><p> 一般默认情况下是用的utf-8与html，可以根据情况在application.properties中进行修改</p><pre><code class="hljs"> spring.thymeleaf.encoding=utf-8 #模版的类型，默认是html，因为模版就是html文件 spring.thymekeaf.mode=HTML</code></pre></li><li><p>设置模版前缀与后缀： 就是设置模版的视图解析器<br>模版前缀 默认放在classpath:&#x2F;template&#x2F; ， 可以进行修改<br>，修改方式类似视图解析器。在application.properties文件中设置</p><pre><code class="hljs"> spring.thymeleaf.prefix=classpath:/template/ spring.thymeleaf.suffix=.html</code></pre></li></ol><p>表示在Controller中返回视图的逻辑地址的时候是在 &#x2F;src&#x2F;resources&#x2F;template文件夹下，寻找后缀为 .html的文件</p><h2 id="二、模版使用"><a href="#二、模版使用" class="headerlink" title="二、模版使用"></a>二、模版使用</h2><p>模版的语法格式： 就是在html标签的属性前加上 th: 从而可以在html标签中获取服务器返回的数据对象。因为只有加了th 才能被模版引擎处理，但是在前端浏览器打开开发者界面的时候不会显示th</p><p>加th的意义，实际上是让其可以根据后端返回的数据来动态更改html的属性<br>可以在xmlns:th&#x3D;”<a href="http://www.w3.org/1999/xhtml&quot;">http://www.w3.org/1999/xhtml&quot;</a> 更改，将换成其他的就可以。</p><ol><li><p>表达式：</p><ol><li>标准变量表达式 <br><br> 语法： ${key}</li></ol><p> 作用：获取key对应的文本数据，key是request作用域中的key，对应变量名。可以使用</p><pre><code class="hljs"> request.setAttribute(key,value) 或 model.addAttribute(key,value)  数据放入reqeust作用域</code></pre><p> 在html的中使用 属性  th:text&#x3D;”${key}” ， 实际上获取的就是对象，如果访问对象的属性，使用的是set，get方法</p><pre><code class="hljs">  &lt;p th:text=&quot;$&#123;user1&#125;&quot;&gt;对象&lt;/p&gt;</code></pre><p> 如果key不存在，则会使用 “” 空字符串将标签中的文本内容进行替代</p><ol start="2"><li>选择变量表达式（星号变量表达式）<br> 语法： *{key}<br> 作用：获取key对应的数据， 注意 ， *{key}不能单独使用，要和 th:object 一起使用，来获取对象的属性值。并且简化 ${key} 每次取出对象属性都要写 ‘ user. ‘的耦合性。</li></ol><p> 注意，只能在th:object 的标签内部使用该对象的属性，标签外无法使用</p><pre><code class="hljs"> &lt;div th:object=&quot;$&#123;user2&#125;&quot;&gt;   首先在div中要获取这个对象     然后在标签中通过* 来使用对象的属性     &lt;p th:text=&quot;*&#123;id&#125;&quot;&gt;id&lt;/p&gt;&lt;br&gt;     &lt;p th:text=&quot;*&#123;name&#125;&quot;&gt;姓名&lt;/p&gt;&lt;br&gt;     &lt;p th:text=&quot;*&#123;age&#125;&quot;&gt;年龄&lt;/p&gt;&lt;br&gt; &lt;/div&gt;</code></pre><ol start="3"><li><p>链接表达式（URL表达式）</p><p> 语法： @{url} <br><br> 作用：表示链接， 可以对一下的类型使用，链接可以是绝对地址也可以是相对地址，适用于<br><br> <script src="">,<link href = ""> <a href=""> <form action=""> <img src =""><br> 链接绝对路径</p><pre><code class="hljs"> &lt;a th:href=&quot;@&#123;http://www.baidu.com&#125;&quot;&gt;链接到百度&lt;/a&gt;</code></pre><p> 链接相对路径 ， 注意开头有无 / 的区别</p><pre><code class="hljs"> &lt;a th:href=&quot;@&#123;/tpl/queryAccount&#125;&quot;&gt;相对地址，没有参数&lt;/a&gt;</code></pre><p> 链接相对路径，用字符串传递参数</p><pre><code class="hljs"> &lt;a th:href=&quot;@&#123;&#39;/tpl/queryAccount?id=&#39;+$&#123;userid&#125;&#125;&quot;&gt;相对地址，将参数缝合在url中传输，从model中获取&lt;/a&gt;</code></pre><p> 然而字符串拼接的传参方式并不是很推荐,推荐使用一下几种方式</p><ol><li><p>使用() 传参数</p><pre><code class="hljs"> &lt;a th:href=&quot;@&#123;/tpl/queryAccount(id=$&#123;userid&#125;)&#125;&quot;&gt;使用() 传参数&gt;&lt;/a&gt;</code></pre></li><li><p>使用() 传递多个参数，参数名字要与后端接受的参数名一致</p><pre><code class="hljs"> &lt;a th:href=&quot;@&#123;/tpl/queryUser(name=&#39;lisi&#39;,age=&#39;20&#39;)&#125;&quot;&gt;使用() 传多个参数&gt;&lt;/a&gt;</code></pre></li></ol></li></ol></li><li><p>属性： 属性是放在html元素中，实际上就是html的属性，只不过加上了th前缀。属性作用不变，只不过加上th以后，属性值会由模版引擎处理，让其可以使用变量表达式。比如：</p><pre><code class="hljs"> &lt;form action=&quot;/login&quot; method=&quot;post&quot;&gt;&lt;/form&gt;</code></pre><p> 也可以写成</p><pre><code class="hljs"> &lt;form th:action=&quot;/login&quot; th:method=&quot;$&#123;method&#125;&quot;&gt;&lt;/form&gt; 获取服务器返回的method变量的值，并作为属性值使用</code></pre></li><li><p>each循环， 可以循环List，Array，Map</p><p> 语法： th:each="集合循环成员，循环状态变量 : ${key}"</p><p> 在html的标签中使用, 其中 集合循环成员，循环状态变量 是可以自定义名称，而且循环状态变量可以不定义<br> 有点类似于foreach，注意，each用在哪个标签上，<strong>哪个标签以及其包裹的内容</strong> 就会循环出现n次</p><pre><code class="hljs"> &lt;div th:each=&quot;集合循环成员，循环状态变量 : $&#123;key&#125;&quot;&gt;     &lt;p th:text=&quot;$&#123;集合循环成员&#125;&quot;&gt;&lt;/p&gt; &lt;/div&gt;</code></pre><p> 循环状态变量 默认名字是 集合循环成员+State。通过该变量可以获得以下信息</p><pre><code class="hljs"> index: 当前迭代对象的索引 count: 当前迭代对象的数量，已经迭代了多少个，从1开始计算 size:  被迭代的对象大小，即 集合中有多少对象 current：当前迭代变量 even/odd : 当前所在的是偶数？奇数？ first：判断是否是一个迭代 last: 判断是否是最后一个迭代</code></pre><p> 注意： 在遍历Map的时候 有 对象.key,对象.value。这个对象就是当前遍历到的map中的kv对象</p></li><li><p>判断条件 if ; unless </p><p> 表达式符号和java中一样，比如== ， 注意，空字符串被认为是true，null被认为false</p><pre><code class="hljs"> &lt;div th:if = &quot;$&#123;表达式&#125;&quot; &gt; 文本内容 &lt;/div&gt;      如果表达式中结果为true，则显示标签体的内容，否则不显示 &lt;div th:unless = &quot;$&#123;表达式&#125;&quot; &gt; 文本内容&lt;/div&gt;   与if相反，除了表达式相等的情况，其他都显示标签体中的内容</code></pre></li><li><p>switch , case 使用方法和java一样，但是所有的case只有一个能匹配成功，匹配成功了才显示标签内的内</p><pre><code class="hljs"> &lt;div th:switch=&quot;要比对的值&quot;&gt;     &lt;p th:case=&quot;值1&quot;&gt; 结果1 &lt;/p&gt;     &lt;p th:case=&quot;*&quot;&gt; 默认结果 &lt;/p&gt; &lt;/div&gt;</code></pre></li><li><p>内联   th:inline 三个取值类型：<strong>text , javascript, none</strong><br> 不用依赖于html标签，直接显示。 </p><pre><code class="hljs"> &lt;p th:text=&quot;&quot;&gt; 而这种形式这是依赖于html的</code></pre><ol><li><p>内联text : 在html标签外获取表达式的值, 可以直接在标签内容后面显示获取的变量值，而不会替代表达式内容<br> 语法：</p><pre><code class="hljs"> &lt;div th:inline=&quot;text&quot;&gt; &lt;p&gt; 显示姓名是 ： [[$&#123;key&#125;]] &lt;/p&gt; &lt;/div&gt;</code></pre></li><li><p>内联javascript : 在 js语句中获取数据, 也可以在事件中使用js方法</p></li></ol></li><li><p>字面量： 包括<strong>数字类型， 文本类型，boolean类型</strong><br> 可以在</p><pre><code class="hljs"> th:text&quot;&quot; 中使用&#39;&#39; 单引号来将 字面量 和 表达式 区分开 &lt;p th:text=&quot;&#39;我是&#39;+ $&#123;sex&#125; + &#39;人&#39;&quot;&gt; 或者 字符串链接 使用| 字符串+ 表达式| 效果一样 &lt;p th:text=&quot;|我是 $&#123;sex&#125;  人|&quot;&gt;</code></pre></li><li><p>运算符： 正常的运算符，但是需要在${} 中使用</p><pre><code class="hljs"> gt,lt,ge,le, 代表 &gt; , &lt; ,&gt;= ,&lt;= eq ,  nq 代表 ==  ， ！=</code></pre><p> 也可以进行多元表达式 </p><pre><code class="hljs"> a &lt; b ? 1 : 2  其中a  ， b 也可以为表达式，可以嵌套</code></pre></li><li><p>内置对象,可以看Thymeleaf的文档来看更多的内置对象</p><ol><li><p>基本对象</p><pre><code class="hljs"> #request：HttpServletRequest #session：HttpSession 直接使用session 也可以表示HttpSession 对象，是#session 的简单方式 可以在模版中直接使用 $&#123;param&#125; 获取请求对象的参数列表，其实使用方法和servlet中使用的方法是一样的</code></pre></li><li><p>内置的工具类功能，可以看Thymeleaf的文档来看更多的内置工具类对象的使用方法（和java类似。<br> 使用的时候注意，在${ }里面的内容，在对象方法中调用变量的时候不需要再写${}</p><pre><code class="hljs"> #dates  $</code></pre></li></ol></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Thymeleaf</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot--打包</title>
    <link href="/2022/02/24/SpringBoot-%E6%89%93%E5%8C%85/"/>
    <url>/2022/02/24/SpringBoot-%E6%89%93%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringBoo项目的打包"><a href="#SpringBoo项目的打包" class="headerlink" title="SpringBoo项目的打包"></a>SpringBoo项目的打包</h1><p>都是使用maven的pacakage功能进行打包，可以在pom中指定打包后文件的名称，文件默认放在 src同级目录下</p><h1 id="一、打包成war文件"><a href="#一、打包成war文件" class="headerlink" title="一、打包成war文件"></a>一、打包成war文件</h1><ol><li><p>修改pom文件</p><pre><code class="hljs"> 打包类型，packaging标签，默认是jar &lt;packaging&gt;war&lt;/packaging&gt; 打包后文件名称 &lt;finalName&gt;myboot&lt;/finalName&gt;</code></pre></li><li><p>主启动类要继承SpringBootServletInitializer 让其可以使用<strong>外部tomcat</strong>，并且要实现configure()方法。这个继承就是代替了原来的web.xml，使用嵌入式servlet，不支持jsp.</p><pre><code class="hljs"> @SpringBootApplication public class PackageWar16Application extends SpringBootServletInitializer &#123; public static void main(String[] args)  &#123;     SpringApplication.run(PackageWar16Application.class, args); &#125; @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) &#123; //        sources 里面是继承extends SpringBootServletInitializer的类的class文件     return builder.sources(PackageWar16Application.class); &#125; &#125;</code></pre></li><li><p>通过外部tomcat访问时候注意:</p><ol><li>打包后将war文件放到Tomcat的webapp下，终端运行tomcat时会自动解压</li><li>打包以后 包名就是访问的context-path，可能与文件的application中的设置不一样</li><li>如果使用外部tomcat，端口默认为8080</li><li>可能遭遇Tomcat在终端无法访问的情况，考虑重新下载tomcat</li></ol></li></ol><h1 id="二、打包称jar文件"><a href="#二、打包称jar文件" class="headerlink" title="二、打包称jar文件"></a>二、打包称jar文件</h1><p>打包jar时，如果有jsp文件，必须指定maven-plugin版本<br>并且在pom文件中指定打包的类型，即 <em>packaging</em> 标签</p><pre><code class="hljs">&lt;packaging&gt;jar&lt;/packaging&gt;</code></pre><p>必须指定spring-boot-maven-plugin的版本</p><pre><code class="hljs">&lt;plugins&gt;    &lt;plugin&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;        &lt;version&gt;1.4.2.RELEASE&lt;/version&gt;  必须指定这个版本    &lt;/plugin&gt;&lt;/plugins&gt;</code></pre><h1 id="三、jar与war的区别"><a href="#三、jar与war的区别" class="headerlink" title="三、jar与war的区别"></a>三、jar与war的区别</h1><p>war：使用外部的独立tomcat服务器，独立tomcat服务器的性能会比内嵌服务器更好，但是同时war包也会更加笨重。</p><p>jar包更轻便，但是内嵌的tomcat在性能上比独立的tomcat弱一些</p>]]></content>
    
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot--RESTful接口架构风格</title>
    <link href="/2022/02/24/SpringBoot-RESTful%E6%8E%A5%E5%8F%A3%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC/"/>
    <url>/2022/02/24/SpringBoot-RESTful%E6%8E%A5%E5%8F%A3%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC/</url>
    
    <content type="html"><![CDATA[<h1 id="一、接口架构风格-：-RESTful"><a href="#一、接口架构风格-：-RESTful" class="headerlink" title="一、接口架构风格 ： RESTful"></a>一、接口架构风格 ： RESTful</h1><p>这里的接口指的是API，application Programming Interface 。 比如函数，http接口。开发人员可以通过接口来访问或调用一些<br>已经开发好的函数功能，但是无需访问源码，也无需了解工作原理.<br>比如：servlet，controller的url实际上就可以视为一个接口</p><pre><code class="hljs">http://localhost:9002/mytransaction/addStudent?name=zhangsan&amp;age=29</code></pre><p>架构风格： 指接口组织的方式，即接口的格式.</p><h1 id="二、REST的意义"><a href="#二、REST的意义" class="headerlink" title="二、REST的意义"></a>二、REST的意义</h1><p>REST：Representational State Transfer，即 <em>表现层状态转移</em> ，它 是一种架构设计风格，并非强制。</p><p>它是客户端和服务器交互时的架构理念和设计原则。基于REST的风格更简洁，更有层次。<br>RESTful 实际上就是使用 <strong>url</strong> 表示资源，使用 <strong>http动作</strong> 来 <strong>操作资源</strong></p><pre><code class="hljs">表现层就是视图层，通过视图页面显示操作结果状态： 指对资源的操作，导致资源的变化  </code></pre><h1 id="三、REST中的要素"><a href="#三、REST中的要素" class="headerlink" title="三、REST中的要素"></a>三、REST中的要素</h1><p>即如何使用REST表示资源 以及 对资源的操作</p><ol><li><p>用 url表示资源，在互联网中，所使用的所有资源都是通过url表示的。</p><pre><code class="hljs">REST在url中使用名词表示资源以及资源访问信息例如：1001是要查询的学生id，REST中使用&quot; / &quot;来分割资源信息格式：http://localhost:8080/myboot/student/1001</code></pre></li><li><p>对资源的操作： CRUD<br> 查询、更新、删除、创建 -&gt; 资源 <br><br> REST中使用http中的动作（<strong>动作指的就是http中的请求方式</strong>），表示对资源的操作。<br><br> 动作包括： （ 这些只是在REST风格下对应的动作 ）</p><ol><li>get 查询资源 （ 1001 是id， 1是学生状态，）</li></ol><pre><code class="hljs"> 查询学生：http://localhost:8080/myboot/student/1001/1 处理多个资源：使用复数形式 http://localhost:8080/myboot/student/1001/1002/1003/...</code></pre><ol start="2"><li>post 创建资源，在post请求中传递数据，前端页面使用表单的模式传递数据</li></ol><pre><code class="hljs"> http://localhost:8080/myboot/student/1002 &lt;form action=&quot;http://localhost:8080/myboot/student&quot; method=&quot;post&quot;&gt;   &lt;input name=&quot;name&quot;&gt;   &lt;input name=&quot;age&quot;&gt; &lt;/form&gt;以下两个方式，浏览器默认不支持，所以使用postman工具来模拟依赖SpringMVC中使用过滤器将收到的post请求转为put和delete   1. 在 application.properties 中开启HiddenhttpMethodFilter过滤器   2. 在请求页面中，需要包含一个_method参数，value为put或delete，发起这个请求时要使用post方式</code></pre><ol start="3"><li>put: 更新资源</li></ol><pre><code class="hljs"> &lt;form action=&quot;http://localhost:8080/myboot/student/1&quot; method=&quot;post&quot;&gt;             &lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;             &lt;input type=&quot;text&quot; name=&quot;age&quot;&gt;             &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;PUT /&gt;             用这样的方法来让浏览器知道实际上要用put来访问     &lt;/form&gt;</code></pre><ol start="4"><li><p>delete: 删除资源，操作与put一样</p></li><li><p>注意： 一些比如分页，排序等参数依然放在url后面。 只有与资源 密切相关的才放在url中,比如</p></li></ol><pre><code class="hljs"> http://localhost:8080/myboot/student?page=1&amp;pageSize=20</code></pre></li></ol><h1 id="四、-RESTful的注解："><a href="#四、-RESTful的注解：" class="headerlink" title="四、 RESTful的注解："></a>四、 RESTful的注解：</h1><p>在模拟http动作的时候，可以使用postman进行模拟发送，减少了写前端页面的操作。</p><pre><code class="hljs">@PathVariable: 从url中获取数据@GetMapping: 支持get请求方式， 等同于 RequestMapping(method=RequestMethod.GET)@PostMapping: 支持post请求方式， 等同于 RequestMapping(method=RequestMethod.POST)@PutMapping：支持get请求方式， 等同于 RequestMapping(method=RequestMethod.PUT)@DeleteMapping：支持get请求方式， 等同于 RequestMapping(method=RequestMethod.Delete)@RestController： 复合注解， 是 @Controller与@ResponseBody的组合:  在某个类上使用@RestController，表示该类的所有方法都加入了@ResponseBody</code></pre>]]></content>
    
    
    <categories>
      
      <category>SpringBoot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RESTful</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring事务的学习</title>
    <link href="/2022/02/24/Spring%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/02/24/Spring%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot-基础使用(三)-数据库相关</title>
    <link href="/2022/02/23/SpringBoot-%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8-%E4%B8%89/"/>
    <url>/2022/02/23/SpringBoot-%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8-%E4%B8%89/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot-基础使用-三-数据库相关"><a href="#SpringBoot-基础使用-三-数据库相关" class="headerlink" title="SpringBoot-基础使用(三) 数据库相关"></a>SpringBoot-基础使用(三) 数据库相关</h1><h2 id="一、Mybatis的使用"><a href="#一、Mybatis的使用" class="headerlink" title="一、Mybatis的使用"></a>一、Mybatis的使用</h2><ol><li><p>在建立的时候需要加入Mybatis框架，以及MySQL Driver驱动<br> mybatis-spring 依赖，来继承mybatis</p></li><li><p>创建dao接口和mapper文件, 创建方法和Mybatis一样</p><p><strong>注意：mapper文件要和接口文件名字一致</strong></p><ol><li><p>方法1: 接口上添加@Mapper注解</p><pre><code class="hljs">/**SpringBoot中需要使用Mapper注解来表示这个接口是dao接口，要创建这个接口的代理对象** @Mapper 的缺点在于 ， 如果有很多接口，那么每个接口都需要加这个注解，比较麻烦* 可以使用 @MapperScan，放在启动类之上* *///注意：配置文件的名字要和接口的名字一致//@Mapperpublic interface studentInfo &#123;    Student selectById(@Param(&quot;stuId&quot;)Integer id);&#125;</code></pre></li><li><p>方法2: 在启动类之上使用 <em>@MapperScan</em></p><pre><code class="hljs">@SpringBootApplication//在启动类使用@MapperScan注解，可以扫描包下的所有mapper.basePackages 是dao所在的包名//可以用数组的形式，指定多个包， &#123;&quot;b1&quot;,&quot;b2&quot;,...&#125;@MapperScan(basePackages=&quot;ormmysql11.ormmysql11.dao&quot;)public class OrmMysql11Application &#123;    public static void main(String[] args) &#123;        SpringApplication.run(OrmMysql11Application.class, args);    &#125;&#125;</code></pre></li><li><p>方法三: 如果dao和mapper文件不在一个包下</p><p>可以将mapper文件放到resources目录下，这样将java文件和mapper文件分离。更清晰.</p><p>在application.properties 文件中指定mapper位置</p><pre><code class="hljs"> mybatis.mapper-locations=classpath:mapper/*.xml </code></pre><p>在resources 目录下mapper文件夹中所有的xml文件<br>（有时候在target目录下会丢失配置文件，在maven中配置resources读取所有文件）</p><pre><code class="hljs">&lt;resources&gt;    &lt;resource&gt;        &lt;directory&gt;src/main/resources&lt;/directory&gt;        &lt;includes&gt;            &lt;include&gt;**/*.*&lt;/include&gt;        &lt;/includes&gt;    &lt;/resource&gt;&lt;/resources&gt;</code></pre></li></ol></li><li><p>在pom文件中配置resources，读取所有xml文件，或者使用上面方法三中的配置</p><pre><code class="hljs"> &lt;resources&gt;             &lt;resource&gt;                 &lt;directory&gt;src/main/java&lt;/directory&gt;                 &lt;includes&gt;                     &lt;include&gt;**/*.xml&lt;/include&gt;                 &lt;/includes&gt;             &lt;/resource&gt; &lt;/resources&gt;</code></pre></li><li><p>在application.properties 中配置数据库</p><pre><code class="hljs"> #配置数据库 spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver spring.datasource.url= spring.datasource.username= spring.datasource.password=</code></pre></li><li><p>设置开启日志,有很多日志的格式，选取需要的类。在application.properties中配置</p><pre><code class="hljs"> mybatis.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl</code></pre></li></ol><h2 id="二、SpringBoot中事务的实现"><a href="#二、SpringBoot中事务的实现" class="headerlink" title="二、SpringBoot中事务的实现"></a>二、SpringBoot中事务的实现</h2><ol><li><p>在业务方法Service实现类上加上 <em>@Transaction</em>，加入注解以后，让方法有事务功能。</p><pre><code class="hljs">/*@Transactional 表示方法有事务支持，如果不设置属性，默认使用数据库的隔离级别 REQUIRED 传播行为                 ： 超时时间 -1                 如果抛出异常，则回滚事务 **/ @Transactional @Override public int addStudent(Student student) &#123;     System.out.println(&quot;插入业务执行了&quot;);     int rows = studentMapper.insert(student);     System.out.println(&quot;执行sql语句&quot;);     //抛出一个runtime exception， 为了回滚事务     //int n = 10/0;     return rows; &#125;</code></pre></li><li><p>在主启动类上面 加入 <em>@EnableTransactionManager</em></p></li><li><p>Mybatis逆向工程插件</p><pre><code class="hljs"> mybatis代码自动生成插件 &lt;plugin&gt;     &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;     &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt;     &lt;version&gt;1.4.0&lt;/version&gt;     &lt;configuration&gt;         指定配置文件，放在项目的根目录之下，与src平级         &lt;configurationFile&gt;GeneratorMapper.xml&lt;/configurationFile&gt;         &lt;verbose&gt;true&lt;/verbose&gt;         &lt;overwrite&gt;true&lt;/overwrite&gt;     &lt;/configuration&gt; &lt;/plugin&gt;</code></pre></li><li><p>使用了Mybatis逆向工程，配置文件信息在GeneratorMapper中查看</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>SpringBoot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Springboot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot-基础使用(二)</title>
    <link href="/2022/02/23/SpringBoot-%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8(%E4%BA%8C)/"/>
    <url>/2022/02/23/SpringBoot-%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8(%E4%BA%8C)/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot使用（二）"><a href="#SpringBoot使用（二）" class="headerlink" title="SpringBoot使用（二）"></a>SpringBoot使用（二）</h1><h2 id="一、Springboot中使用容器的体现"><a href="#一、Springboot中使用容器的体现" class="headerlink" title="一、Springboot中使用容器的体现"></a>一、Springboot中使用容器的体现</h2><p>SpringBoot主启动类的main方法主要内容是</p><pre><code class="hljs"> public static void main(String[] args) &#123;    SpringApplication.run(ManyEnv05Application.class, args);&#125;</code></pre><p>其中 <em>Application.run()</em> 的返回结果是<em>ConfigurableApplicationContext</em>，这个类继承了<em>ApplicationContext</em> ，而<em>ApplicationContext</em> 是一个容器对象。所以实际上run的返回值就是一个容器对象，同样可以通过getBean的方法从中获取对象</p><pre><code class="hljs">ApplicationContext applicationContext = SpringApplication.run(SpringbootApplicationcontext07Application.class, args);applicationContext.getBean(&quot;&quot;);</code></pre><h2 id="二、CommandLineRunner接口"><a href="#二、CommandLineRunner接口" class="headerlink" title="二、CommandLineRunner接口"></a>二、CommandLineRunner接口</h2><p>CommandLineRunner与ApplicationRunner接口中都存在run方法*run()*方法的执行时机都是在 <strong>容器启动之后</strong>。这就意味着是在容器创建对象之后再执行，因此他们都可以从容器中获取对象<br>他们区别在于： <strong>两者run()方法中传入的参数不同</strong>。<br></p><pre><code class="hljs">CommandLineRunner的run参数为：run(String ...args)ApplicationContext的run参数为：run(ApplicationContext.class, String[] args)</code></pre><p>注意： 这里的<strong>ApplicationContext.class</strong> 文件，指的是具有 <strong>@SpringBootApplication的主启动类的.class文件</strong></p><h2 id="三、拦截器的使用"><a href="#三、拦截器的使用" class="headerlink" title="三、拦截器的使用"></a>三、拦截器的使用</h2><ol><li><p>需要创建自己的拦截器类，并实现HandlerInterceptor接口。HandlerInterceptor接口的三个方法有default，重写需要用到的方法即可。</p><pre><code class="hljs"> public class MyInterceptor implements HandlerInterceptor &#123; /**HttpServletRequest request, HttpServletResponse response, Object handler : 被拦截的控制器对象 return : true ,能被处理 ； false， 请求截断 * */     @Override     public boolean preHandle(HttpServletRequest request,                             HttpServletResponse response,                             Object handler) throws Exception &#123;         System.out.println(&quot;拦截器起作用了&quot;);         return true;     &#125; &#125;</code></pre></li><li><p>创建一个配置类，实现WebMvcConfigurer接口，其中有addInterceptor方法.注意，要给这个配置文件加上@Configuration注解，拦截器才可以起作用</p><pre><code class="hljs"> @Configuration // 记得要将本文件作为configuration使用，否则拦截器不会被配置 public class MyApplicationConfig implements WebMvcConfigurer &#123;     //添加拦截器对象，并注入到容器中     @Override     public void addInterceptors(InterceptorRegistry registry) &#123;         //创建拦截器对象：         HandlerInterceptor interceptor = new MyInterceptor();         // 让拦截器拦截哪些网址 , 可以使用list数组，一次拦截多个uri地址         //registry.addInterceptor().addPathPatterns();         //registry.addInterceptor().excludePathPatterns(); // 让拦截器不拦截哪些网址         String[] path = &#123;&quot;/user/**&quot;&#125;;         String[] exclude = &#123;&quot;/user/login&quot;&#125;;         registry.addInterceptor(interceptor)                 .addPathPatterns(path)                 .excludePathPatterns(exclude);     &#125; &#125;</code></pre></li></ol><h2 id="四、Servlet的使用"><a href="#四、Servlet的使用" class="headerlink" title="四、Servlet的使用"></a>四、Servlet的使用</h2><ol><li><p>首先创建一个Servlet类 实现HttpServlet接口。</p></li><li><p>有两种方法可以注册Servlet对象</p><pre><code class="hljs"> @Configuration public class ServletConfig &#123; //    方法一：利用ServletRegistrationBean的有参构造 @Bean //    定义方法，注册Servlet对象，通过返回值的方法来使用servlet public ServletRegistrationBean servletRegistration()&#123; //     注册类的构造方法： new ServletRegistrationBean&lt;&gt;(T servlet , String url )     /*第一个参数是我们的servlet对象，第二个是url地址*/     ServletRegistrationBean bean = new ServletRegistrationBean(                                     new MyServlet(), &quot;/myservlet&quot;);     return bean; &#125; //    方法二： @Bean public ServletRegistrationBean servletRegistration2()&#123;     //利用ServletRegistrationBean的无参构造     ServletRegistrationBean bean = new ServletRegistrationBean();     bean.setServlet(new MyServlet());     bean.addUrlMappings(&quot;/test&quot;,&quot;/login&quot;); // 可以指定servlet处理多个uri                                 //addUrlMappings实际上就是 url-partten标签     return bean; &#125;</code></pre></li></ol><p>}</p><h2 id="五、过滤器的使用"><a href="#五、过滤器的使用" class="headerlink" title="五、过滤器的使用"></a>五、过滤器的使用</h2><ol><li><p>建立过滤器对象，实现的是Servlet规范中的Filter，以及doFilter()方法</p></li><li><p>建立配置类文件，并注册过滤器到容器中，这一步和servlet是一样的<br> @Bean<br> public FilterRegistrationBean filterRegistrationBean(){<br> FilterRegistrationBean f &#x3D; new FilterRegistrationBean();<br> f.setFilter( new myfilter());<br> &#x2F;&#x2F;配置过滤器地址<br> f.addUrlPatterns(“&#x2F;user&#x2F;*”);<br> return f;<br> }</p></li><li><p>修改外部配置文件 application.properties</p><pre><code class="hljs"> server.servlet.encoding.enabled=false</code></pre></li></ol><p>SpringBoot中默认已经配置了CHaracterEncodingFilter，但是他默认是ISO-8859-1.<br>如果这里为true，他会使用原本默认的过滤器；设置为false，关闭系统中默认的过滤器<br>所以也可以在这个配置文件中来设置框架默认的字符集过滤器，也可以用以解决乱码问题.</p><ol start="4"><li><p>修改默认字符集的第二种方式，直接在application.properties 中进行修改</p><pre><code class="hljs"> server.servlet.encoding.enabled=true server.servlet.encoding.charset=utf-8 server.servlet.encoding.force=true  用force就把请求和response都使用charset的值</code></pre></li></ol><p>也可以指定某一项使用charset值<br>        server.servlet.encoding.force-request&#x3D;true<br>        server.servlet.encoding.force-response&#x3D;true</p>]]></content>
    
    
    <categories>
      
      <category>SpringBoot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Springboot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot-基础使用(一)-项目基本配置</title>
    <link href="/2022/02/23/SpringBoot-%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8(%E4%B8%80)/"/>
    <url>/2022/02/23/SpringBoot-%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot-项目基本配置-学习笔记（一）"><a href="#SpringBoot-项目基本配置-学习笔记（一）" class="headerlink" title="SpringBoot-项目基本配置 学习笔记（一）"></a>SpringBoot-项目基本配置 学习笔记（一）</h1><h2 id="一、使用springboot提供的初始化器"><a href="#一、使用springboot提供的初始化器" class="headerlink" title="一、使用springboot提供的初始化器"></a>一、使用springboot提供的初始化器</h2><p>New Module -&gt; Spring Initializer -&gt; default -&gt; 然后按照显示的内容自定义在创建的时候，在国内可以在Custom处使用 <a href="https://start.springboot.io/">https://start.springboot.io</a> 这个地址是一个创建向导，也可以通过浏览器访问。<br><br>Springboot 内嵌了tomcat,Jetty,等服务器。并且提供了starter启动器依赖，在starter中实际上就将常用的一些对象进行了创建和配置，具体会在之后的文章讨论。<br><br>springboot尽量自动的配置spring和第三方库，减少人工配置的压力。它会将第三方库中的对象都配置好，放到容器中。<br><br>提供 metrics, health checks and externalized configuration 功能, 即： <br><br>        度量 , 健康检查（工作状态是否正常） ， 外部化配置（就是项目代码之外的配置，比如propoties文件）</p><span id="more"></span><h2 id="二、springboot的项目结构"><a href="#二、springboot的项目结构" class="headerlink" title="二、springboot的项目结构"></a>二、springboot的项目结构</h2><p>Springboot 主要是由src&#x2F;main下的java和resources文件夹构成的，他们分别存放的主要内容如下。</p><ol><li><p>java: <br></p><ol><li>SpringBootApplication 类， 作为Springboot项目的启动类，启动其中的main方法后相当于启动了一个tomcat服务器。</li><li>运行SpringBootApplication的Main方法以后，在控制台会显示运行信息。</li></ol></li><li><p>resources : <br></p><ol><li>static : 放置静态资源文件</li><li>tamplates: 放置模版文件，如果项目中没有使用模版文件，可以删除</li><li>application.properties: springboot 重要的配置文件，也可以使用yml格式</li></ol></li><li><p>.yml文件与.properties配置文件的区别：格式不同 ， 但是都是使用 (K,V)格式来存储数据</p><ol><li><p>.yml  <br><br> 使用冒号 “**:**”  来表示K与V的对应关系，更有层次。例如：</p><pre><code class="hljs"> server:     port: 8083     servlet:         context-path: /myboot2</code></pre></li><li><p>.properties <br><br>使用等号 “**&#x3D;**” 来表示</p><pre><code class="hljs">server.port=8082</code></pre></li></ol></li></ol><h2 id="三、-Springboot项目的application配置文件内容"><a href="#三、-Springboot项目的application配置文件内容" class="headerlink" title="三、 Springboot项目的application配置文件内容"></a>三、 Springboot项目的application配置文件内容</h2><p>Springboot 的一些配置，比如访问的根目录，使用端口等都可以在application文件下配置<br><br>配置文件的<strong>必须是application</strong><br><br>文件扩展名可以是 .properties <strong>(k&#x3D;v)</strong> 或者 yml <strong>(k:v)</strong> 格式<br><br>因此可以是 application.properties 或者 application.yml，但是默认情况下优先使用.properties。即如果两种格式文件同时出现，会优先使用properties。</p><ol><li><p>设置端口号</p><pre><code class="hljs"> server.port=8082</code></pre></li><li><p>设置访问的上下文路径 contextpath </p><pre><code class="hljs"> server.servlet.context-path=/myboot</code></pre><p> 如果此时controller中的访问路径是&#x2F;hello , 则需要浏览器在访问的时候使用<em><a href="http://localhost:port/myboot/hello">http://localhost:port/myboot/hello</a></em> 这样的形式来访问</p></li><li><p>多环境配置:  可以在resources中创建多个环境文件，以便于在 开发&#x2F;测试&#x2F;用户使用环境中切换</p><pre><code class="hljs"> 文件名称格式:  application-环境名称.properties 或 application-环境名称.yml</code></pre><p> 并且在 application文件，这里暂称为<em>主配置文件</em> , 中配置属性。</p><pre><code class="hljs"> 假设此时开发环境的配置文件为：application-dev.properties 那么对应在application文件中就要设置 spring.profiles.active=dev 此时springboot会去找 application+&quot;-&quot;+dev 这个配置文件。</code></pre></li><li><p>从配置文件中获取数据</p><ol><li><p>在java类中可以在要复制的变量上方使用 <strong>@Value(“${key}”)</strong> 从配置文件中获取数据</p></li><li><p>可以通过配置文件为java对象的属性赋值，这样有很多值的时候不用一个个赋值。<br>在配置文件中找到要获取的信息的前缀，然后框架会将 <strong>前缀.属性名</strong>的值拿出来，和对象中的<strong>属性名</strong>进行比较，给相同的赋值.比如：</p><pre><code class="hljs">  @Component  @ConfigurationProperties(prefix = &quot;school&quot;) //设置前缀，前缀的默认是空  //在配置文件中配置的时候，  public class School &#123;      private String name;      private String website;  &#125;  此时配置文件中配置了school对象的属性信息  school.name = USYD  school.website = www.baidu.com</code></pre></li><li><p>要使用注解时候，需要在pom加入依赖， 处理ConfigurationProperties有关的元数据</p><pre><code class="hljs"> &lt;dependency&gt;     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;     &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;     &lt;optional&gt; true&lt;/optional&gt; &lt;/dependency&gt;</code></pre></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>SpringBoot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GAN 学习笔记</title>
    <link href="/2022/02/04/GAN/"/>
    <url>/2022/02/04/GAN/</url>
    
    <content type="html"><![CDATA[<h1 id="Gan论文总结"><a href="#Gan论文总结" class="headerlink" title="Gan论文总结"></a>Gan论文总结</h1><h2 id="一、GAN结构"><a href="#一、GAN结构" class="headerlink" title="一、GAN结构"></a>一、GAN结构</h2><p>GAN主要由两个部分组成： 判别模型D与生成模型G。<br/><br>1.随机噪声通过G生成目标数据，G的目的是尽可能让D判断错误，让D误以为G生成的数据是真实数据<br/><br>2.判别器D估计数据是否来源于真实数据，最大化 “正确分配真实样本和生成样本” 的概率</p><span id="more"></span><h2 id="二、价值函数"><a href="#二、价值函数" class="headerlink" title="二、价值函数"></a>二、价值函数</h2><img src="/2022/02/04/GAN/bb101d1e251ee00004fb247bc5cf1bcc4216175af39c735a8cbd1c26d617691c.png" class="" title="[图 13]"><p>其中，z是一个随机生成的噪声，G是多层感知机表征的可微函数，同样的定义第二个多层感知机D，输出单个标量,即 1或0：表示判别器判定进入的图片是真还是假。</p><p>$D(x)$表示x来源于真实数据的概率，当x的分布完全符合真实数据的分布,即x是真实数据时：$D(x)&#x3D;1$。 因此$ D(G(x))$ 表示G生成的数据被判断为真实数据的概率。</p><h3 id="2-1-价值函数的意义"><a href="#2-1-价值函数的意义" class="headerlink" title="2.1 价值函数的意义"></a>2.1 价值函数的意义</h3><p>对于判别器的价值函数，即 D_V(D,G)而言，最好的判别器就是让  $D(G(z))&#x3D;0$。当 $D(G(z))&#x3D;0$时，即此时$log(1-D(G(z)))&#x3D;0$,那么此时 $V(D,G) &#x3D; E_x{p_{data}}[logD(x)]$ 则 $V(D,G)$最大。<br>因此可以将最优的D* 定义为 $D*_G&#x3D;argmax_DV(G,D)$</p><p>而对于生成器G 而言， G_V(D,G) 就是让其中的 $D( G(z)))$ 尽可能大，则 $1-D(G(z)$)尽可能小。 而在判别器正确分类所有”真“图片的情况下， 最优的生成器G就会让 $V(G,D)$的值最小。</p><p>因此形成了生成器G和判别器D的最大最小博弈。</p><h3 id="2-2-训练过程"><a href="#2-2-训练过程" class="headerlink" title="2.2  训练过程"></a>2.2  训练过程</h3><p>在最大最小博弈的训练过程中，实际上对于两个模型是分开训练的。</p><p>第一步： 训练判别器D: 固定生成器G，先让$V(G,D)$ 最大化。<br/><br>第二步： 固定判别器D, 训练生成器G: 最小化$V(G,D)$<br/><br>其中第一步的过程，在固定生成器G，最大化V(G,D)的过程，实际上是判别器D在评估生成器G所生成的 “假”数据 P_G 与 真实数据 P_data 之间的差距。<br/><br>我们的目的往往是要得到最优的生成器G*, 因此可以将G* 看作是让V(G,D)最小的G。即 $G*&#x3D;argmin_GV(G,D)$</p><h2 id="三、"><a href="#三、" class="headerlink" title="三、"></a>三、</h2><p>论文中度量生成分布P_G 与真实分布 P_data 之间差异的方法是JS散度,而JS散度实际上是通过KL散度所构建的。KL散度可以用最大似然估计进行推导。<br>其似然函数为：<br>$$L &#x3D; \prod_{i&#x3D;1}^{m} P_G(x^i;\theta)$$<br>其中 x_i 为真实样本， $\theta$是生成器的参数(w,b)。 该公式的意义是： 当生成器的参数$\theta$固定后，生成的结果分布与 $x_i$ 分布相同的概率。<br/><br>因此最优生成器的目的就是让生成的 “假”样本分布与真实样本的分布无限接近。即： P_G&#x3D;&#x3D; P_data，也可以理解为：生成器所生成的数据有很大概率是一个真实数据。<br/><br>L作为m 个真实样本在 $P_G$ 中出现的概率，因此我们希望在$P_G$的情况下，这m个样本尽可能多的出现,由此可以通过用最大似然估计将L最大化，从而求出 $\theta^*$。</p><img src="/2022/02/04/GAN/17f2cca35e11cc60efffce2d3da3bab2414ea4a2bbb2c4d150a5da885a70ae82.png" class="" title="[图 3]"><p>当期望展开后发现最大化 $\theta$实际上就是求其最小化的KL散度。</p><h2 id="四、证明当P-G-x3D-x3D-P-data的时候-最优生成器G-是可以达到的"><a href="#四、证明当P-G-x3D-x3D-P-data的时候-最优生成器G-是可以达到的" class="headerlink" title="四、证明当P_G &#x3D;&#x3D; P_data的时候 最优生成器G* 是可以达到的"></a>四、证明当P_G &#x3D;&#x3D; P_data的时候 最优生成器G* 是可以达到的</h2><h3 id="4-1-最优判别器-D-，假设其有最优解并证明"><a href="#4-1-最优判别器-D-，假设其有最优解并证明" class="headerlink" title="4.1 最优判别器: D* ，假设其有最优解并证明"></a>4.1 最优判别器: D* ，假设其有最优解并证明</h3><p>原论文中价值函数可以写为在x上的积分。也就是说都符合x的分布（因为最后的G(Z) 生成的数据实际上接近真实分布）。将数学期望展开成积分形式，$D* &#x3D; argmax V(G,D)$,即要求积分最大值，而积分最大值可以转换为求被积函数最大值。</p><img src="/2022/02/04/GAN/3445c850cac677c303156ff592fa3ea8e304fe53a982ba6ef4991803ef5599c0.png" class="" title="[图 4]"><p>在被积函数中，因为分布和生成器已经固定，所以只有D(x) 作为变量。 因此令D(x)为y，则可以等同于，其中a，b视为概率数值（常数）。 然后通过求二阶导数判断是否成立</p><p>由于一阶导数大于0，二阶导数小于0，因此可以判断此时  $a&#x2F;(a+b)$是极大值。 注意，这里的a是P_data(x) , b是P_G(x) 概率分布。因此<br>$$V(G,D) &lt;&#x3D; P_{data} &#x2F; (P_{data}(x)+P_G(x))$$</p><h3 id="4-2-最优生成器-G"><a href="#4-2-最优生成器-G" class="headerlink" title="4.2 最优生成器: G*"></a>4.2 最优生成器: G*</h3><p>假设最优生成器G* 存在，即此时 P_G&#x3D;&#x3D;P_data。 将其带入D* ,会发现 $D*(G*)&#x3D;1&#x2F;2$ 此时判别器D产生困惑，分不清真假数据，概率都是0.5。<br>根据前面的D*推导，我们可以得到训练标准C(G)。</p><img src="/2022/02/04/GAN/0453f2c1a11286d7a1f48de68de3784b9f4c0d04895ffa4d8c19f2f44df0be1e.png" class="" title="[图 12]"><p>通过反向验证（即设P_G&#x3D;P_Data） 将 $D * G &#x3D; 1&#x2F;2$ 带入 V(G,D*)可以发现$-log4$是全局最小的候选。<br>在每个积分项中加上或减去log2 * 概率密度的技巧，让C(G)含log2，并将其转换成JS散度形式。并且概率密度函数在积分域上的积分为1，所以最后可以转化为</p><img src="/2022/02/04/GAN/bb263fb633d6236fa2ec9d0fc17d524332acc62496d4169631bc4e1bd5a8081d.png" class="" title="[图 8]"><p>可以发现，此时第二、第三项其实就是KL散度，而KL散度非负，所以-log4是全局最小值。同时可以讲C(G)写成</p><p>$$ C(G)&#x3D;-log4+KL(p_{data}| \frac{p_{data}+p_G}{2}) + KL(p_G|\frac{p_{data}+p_G}{2})$$</p><p>因为KL散度的不对称性，所以此时$KL(p_{data} | (P_{data}+P_G)&#x2F;2)$ 中的左右两项是不能交换的，但如果同时加上另一项$KL(p_{G} | (P_{data}+P_G)&#x2F;2)$ ,两者的和可以变为对称项。<br>这两项的和就可以表示为JS散度</p><p>$$JDS(P||D) &#x3D; \frac{1}{2}D(P||M)+\frac{1}{2}D(Q||M) ; 其中 M&#x3D;\frac{1}{2}(P+Q)$$</p><p>因此当且仅当 P_G &#x3D; P_data 的时候，可以达到 训练标准 $C(G)&#x3D;maxV(G,D)$ 的全局最小值，因为这时候P_G与P_data的 JS散度$[JSD(P_{data}(x) || P_G(x))]&#x3D;&#x3D;0$<br>因此可以将训练标准 C(G) 写成：<br>$$ C(G)&#x3D;-log4+2*JSD(p_{data}|p_G)$$</p><h2 id="五、训练过程"><a href="#五、训练过程" class="headerlink" title="五、训练过程"></a>五、训练过程</h2><h3 id="5-1-生成器G的损失函数"><a href="#5-1-生成器G的损失函数" class="headerlink" title="5.1 生成器G的损失函数"></a>5.1 生成器G的损失函数</h3><p>损失函数训练时往往是求最小值，所以对于生成器来说是求$argmaxV(G,D)$的最小值，而判别器要求$V(G,D)$的最大值，可将其转换成$-V(G,D)$的最小值，这样可以将两个损失函数都转化为求最小值问题。</p><p>生成器训练： 给定D* 将 损失函数$L(G) &#x3D; argmaxV(G,D)$.因为在$V(G,D)$中只有第二项涉及到G，因此在求导后损失函数转为：</p><p>$$ argmin\hat{V} &#x3D;argmin \frac{1}{m} \sum_{i&#x3D;1}^mlog( 1-D(G(z^i)) )$$<br>可以将其中的1-提出变为负号，即loss是<br>$$ argmin\hat{V} &#x3D;argmin -\frac{1}{m} \sum_{i&#x3D;1}^mlog(D(G(z^i)) )$$</p><h3 id="5-2-判断器D的损失函数"><a href="#5-2-判断器D的损失函数" class="headerlink" title="5.2 判断器D的损失函数"></a>5.2 判断器D的损失函数</h3><p>对给定的 G* ,将生成器G的参数固定， 并将 $-V(G,D)$ 作为损失函数，使用一些常见的优化器进行训练。<br>由于数学期望无法真正求得，所以大数定理用m个样本来求近似表达式。</p><p>1.对于判别器而言要求以下V的最大值</p><p>$$argmax \hat{V}&#x3D;\frac{1}{m} \sum_{i&#x3D;1}^mlogD(x^i)+\frac{1}{m} \sum_{i&#x3D;1}^mlog(1-D(\hat{x}^i))$$</p><p>采用等价形式训练。将逼近 $-\hat{V}$ 作为损失函数，将P_data(X) 作为正样本 $x$，P_G(x)作为负样本 $\hat{x}$。可以得到L</p><p>$$argmin L &#x3D; -\frac{1}{m} \sum_{i&#x3D;1}^mlogD(x^i)-\frac{1}{m}\sum_{i&#x3D;1}^mlog(1-D(\hat{x}^i))$$</p><p>注意，训练过程中不能完整优化D，会导致过拟合。一般在k次优化D之后优化一次G。</p><p>附上手写数字训练代码：</p><p>首先是判别器模型：<br>    # Erik pattern<br>    import tensorflow as tf<br>    import numpy as np<br>    from tensorflow.keras.layers import Dense<br>    from tensorflow.keras import Model<br>    import tensorflow.keras.layers as layers<br>    class discrimination_model(Model):<br>        def <strong>init</strong>(self):<br>            super(discrimination_model, self).<strong>init</strong>()</p><pre><code class="hljs">    def  get_d_model(self):    model = tf.keras.Sequential([        layers.Conv2D(64, (5,5) ,padding=&#39;same&#39;, input_shape=(28,28,1),activation=&#39;tanh&#39;),        layers.MaxPooling2D(pool_size=(2,2)),        layers.Conv2D(128,(5,5),activation=&#39;tanh&#39;),        layers.MaxPooling2D(pool_size=(2,2)),        layers.Flatten(),        layers.Dense(1024,activation=&#39;tanh&#39;),        layers.Dense(1,activation=&#39;sigmoid&#39;)    ])    return model</code></pre><p>然后是生成器器模型<br>    # Erik pattern<br>    import tensorflow as tf<br>    import numpy as np<br>    from tensorflow.keras import Model<br>    from tensorflow.keras.layers import Dense</p><pre><code class="hljs">class generator_model(Model):    def __init__(self):        super(generator_model,self).__init__()        self.d1 = Dense(input_dim=100,units=1024,activation=&#39;tanh&#39;)        self.d2 = Dense(input_dim=1024, units=128*7*7)        self.d3 = tf.keras.layers.BatchNormalization()        self.d4 = tf.keras.layers.Activation(&#39;tanh&#39;)        self.d5 = tf.keras.layers.Reshape( (7,7,128), input_shape=(128*7*7,) )        self.d6 = tf.keras.layers.UpSampling2D(size=(2,2))        self.d7 = tf.keras.layers.Conv2D(64, (5,5), padding=&#39;same&#39;,activation=&#39;tanh&#39;)        self.d8 = tf.keras.layers.UpSampling2D(size=(2,2))        self.d9 = tf.keras.layers.Conv2D(1, (5,5), padding=&#39;same&#39;,activation=&#39;tanh&#39;)    def call(self,x):        y = self.d1(x)        y = self.d2(y)        y = self.d3(y)        y = self.d4(y)        y = self.d5(y)        y = self.d6(y)        y = self.d7(y)        y = self.d8(y)        y = self.d9(y)        return y    # 固定d，并将g和d拼接训练    def generator_containing_discriminator(self, g,d):        model = tf.keras.Sequential()        model.add(g)        d.trainable = False        model.add(d)        return model</code></pre><p>最后是训练过程</p><pre><code class="hljs"># Erik patternimport mathimport D_model as discriminationimport Generator_model as generatorimport tensorflow as tfimport tensorflow.keras.datasets.mnist as ministimport numpy as npimport matplotlib.pyplot as pltfrom PIL import Imagedef train(BATCH_SIZE):    (xtrain, ytrain), (xtest, ytest) = minist.load_data()    xtrain = (xtrain.astype(np.float32 ) - 127.5) / 127.5    xtrain = xtrain[:,:,:,None]  # 增加xtrain的维度使其能顺利喂入神经网络    xtest = xtest[:,:,:,None]    #生成模型    di = discrimination.discrimination_model()    d = di.get_d_model()    g = generator.generator_model()    d_on_g = g.generator_containing_discriminator(g=g,d=d)    #定义模型的优化器    d_op = tf.keras.optimizers.SGD(lr=0.01,momentum=0.9,nesterov=True)    g_op = tf.keras.optimizers.SGD(lr=0.01,momentum=0.9,nesterov=True)    # 将g先compile    g.compile(loss=&#39;binary_crossentropy&#39;,optimizer=&#39;SGD&#39;)    #冻结d    d_on_g.compile(loss=&#39;binary_crossentropy&#39;,optimizer=g_op)    #将d解冻    d.trainable=True    d.compile(loss=&#39;binary_crossentropy&#39;,optimizer=d_op)    for epoch in range(30):        print(&quot;Epoch is : &quot; , epoch)        print(&quot;Number of batches&quot;, int(xtrain.shape[0] / BATCH_SIZE))        for batch in range( int(xtrain.shape[0] / BATCH_SIZE)):            noise = np.random.uniform(-1,1,size=(BATCH_SIZE,100))            # 从真实数据xtrain中取出batch个图片            image_bach = xtrain[batch*BATCH_SIZE:(batch+1)*BATCH_SIZE]              # 根据输入的随机噪声输出图片            generated_image = g.predict(noise,verbose=0)             # 每经过100次迭代输出一张生成的图片            if batch % 100 == 0:                image = combine_images(generated_image)                image = image * 127.5 + 127.5                Image.fromarray(image.astype(np.uint8)).save(                    &quot;./GAN/&quot; + str(epoch) + &quot;_&quot; + str(batch) + &quot;.png&quot;)            # 将真实图片与生成图片通过通道的方式组合，真实图片先，生成图片后            x = np.concatenate( (image_bach,generated_image) )            # 生成对应标签            y = np.array( [1] * BATCH_SIZE + [0] * BATCH_SIZE)            d_loss = d.train_on_batch(x,y)            # d.fit(x, y, batch_size=BATCH_SIZE,epochs=1) 在此情况下由于要对数据集进行修改，数据集并不是封闭的，所以不能用fit            # print(&quot;batch %d d_loss : %f&quot; % (batch, d_loss))            noise = np.random.uniform(-1,1,size=(BATCH_SIZE,100))            d.trainable=False            # 冻结D，由G通过noise输出生成的图片进入D            # 将生成的标签标记为真 ！ 这里的原因是：标记为真形成的误差就会大，生成器权值更新也会大            # 如果标记为假的话，那判别器实际上大概率能正确判断，造成最后输出的误差会很小，权值更新也就小了            y2 = np.ones(BATCH_SIZE)            g_loss = d_on_g.train_on_batch(noise , y2)            # d_on_g.fit(noise,y2,batch_size=BATCH_SIZE,epochs=1)            d.trainable = True            # print(&quot;batch %d g_loss : %f&quot; % (batch, g_loss))            # 每100次迭代保存一次生成器和判别器的权重            if batch % 100 == 9:                g.save_weights(&#39;generator&#39;, True)                d.save_weights(&#39;discriminator&#39;, True)def combine_images(generated_images):    #生成图片拼接    num = generated_images.shape[0]    width = int(math.sqrt(num))    height = int(math.ceil(float(num)/width))    shape = generated_images.shape[1:3]    image = np.zeros((height*shape[0], width*shape[1]),                    dtype=generated_images.dtype)    for index, img in enumerate(generated_images):        i = int(index/width)        j = index % width        image[i*shape[0]:(i+1)*shape[0], j*shape[1]:(j+1)*shape[1]] = \            img[:, :, 0]    return imagetrain(32)</code></pre>]]></content>
    
    
    <categories>
      
      <category>GAN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GAN</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
